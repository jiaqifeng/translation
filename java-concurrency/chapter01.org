* Chapter 1. 简介

写出正确的程序很难;写出正确的并发程序更难。简单的说,并发程序比串行程序有更多的容易出错的地方。那么，为什么我们还要写并发程序呢？线程是Java语言不可或缺的特性，它们可以通过将复杂的异步代码转换为更简单的线性代码来简化复杂系统的开发。此外，线程是利用多处理器系统的计算能力的最简单方法。而且，随着处理器数量的增加，有效利用并发性只会变得更加重要。

** 1.1.  并发简史

在过去，计算机还没有操作系统的时候,它们从头到尾的执行单个程序，程序可以直接访问机器的所有资源。 编写一个在裸机上运行的程序不仅很难，而且一次只运行一个程序也浪费了昂贵且稀缺的计算机资源。

操作系统出现后,允许同时运行多个程序，不同的程序运行在不同的进程中.进程被互相隔离，分别独立的执行程序,而操作系统负责将内存，文件句柄和安全凭证等资源分配给各个进程。如果有必要，进程可以通过多种粗粒度的通信机制彼此通信,如套接字，信号处理，共享内存，信号量和文件。

促成了开发操作系统使得多个程序可以同时执行的激励因素包括：

 *资源利用* 程序有时必须等待输入或输出等外部操作，在等待时不能进行其他工作。此时允许其他程序运行能提高资源的利用率。

 *公平* 多个用户和多个程序可能对机器的资源具有相同的使用权。与其让一个程序从头执行到尾,不如将计算资源按时间进行细粒度的分片,让所有程序共享。

 *方便* 与其写一个程序完成所有工作,不如分成多个程序,每个完成单一任务,通过多个程序的协调合作来完成任务.

在早期的分时系统中，每个进程相当于一个虚拟的冯·诺依曼计算机,它有一个内存空间用于存储指令和数据，根据机器语言的语义,顺序地执行指令，并通过一组I/O原语通过操作系统与外界进行交互。对于每个执行的指令，都有一个明确定义的“下一条指令”，根据指令集的规则,控制流"流"过程序指令。今天几乎所有广泛使用的编程语言都遵循这种顺序编程模型，语言的规范明确定义了执行一个操作后“接下来会发生什么”。

顺序编程模型是直观和自然的，因为它模拟了人类工作的方式：按顺序一次做一件事,在绝大多数情况下。起床，穿上浴衣，下楼去喝茶。和编程语言一样，在真实世界中,完成一件工作被抽象为一系列细粒度的操作,打开橱柜，选一种茶叶，将茶放入锅中，看看茶壶中是否有足够的水，如果不足就加水，把壶放在炉子上，点火，等待水沸腾，如此等等。其中最后一步, 等待水沸腾,也存在着某种程度的异步性。在水加热的同时，你可以选择等待或者干点别的，比如开始烤面包（另一个异步任务）或者看报纸，同时还要留意茶就快烧好了。茶壶和烤面包机的制造商知道他们的产品通常会以异步的方式使用，因此在完成任务时这些设备会发出响声表示工作完成了。正确的平衡异步的和顺序的工作通常是高效人士的特征--程序也是如此。

促使进程概念出现的因素（资源利用，公平性和便利性）同样也促使了线程概念的出现。线程允许在一个进程中有多个控制流同时存在。它们共享整个进程范围内的资源，例如内存和文件句柄，但每个线程都有自己的程序计数器，堆栈和局部变量。将进程分解为多线程,能够自然的利用多处理器系统的硬件并行性,一个程序中的多个线程可以调度到多个CPU上同时运行。

线程有时被称为轻量级进程，大多数现代操作系统将线程而非进程视为调度的基本单位。在没有显式协调的情况下，线程彼此同时且异步地执行。由于多个线程共享其同一进程的内存地址空间，因此进程中的所有线程都可以访问同一个变量并从同一个内存堆中分配对象，这允许了比进程间通信机制更精细的数据共享。但是，如果不显式地对共享数据的访问进行协调，则一个线程可以修改另一个线程正在使用的变量，导致不可预测的结果。

** 1.2. 线程的好处

如果使用得当，线程可以降低开发和维护成本，并提高复杂应用程序的性能。通过将多个异步工作流转换为多个顺序执行为主的工作流，线程可以更容易地模拟人类的工作和交互方式。它们还可以将犬牙交错的复杂代码转换为更容易编写，读取和维护的顺序代码。

线程在GUI应用程序中非常有用，可以提高用户界面的响应速度，在服务器应用程序中可以提高资源利用率和吞吐量。线程还简化了JVM的垃圾收集器的实现,垃圾收集器通常运行在一个或多个专用的线程中。大多数重要的Java应用程序在某种程度上依赖于合理使用线程。

*** 1.2.1. 发挥多处理器的能力

多处理器系统在过去既昂贵又罕见，仅在大型数据中心和科学计算设施中才能找到。但在今天是既便宜又多见,甚至低端服务器和中端桌面系统通常都有多个处理器。这种趋势只会加速,随着增加时钟频率变得越来越困难，处理器制造商将把更多的处理器内核放在一个芯片上。主流的芯片制造商都已开始这种转变，而且我们已经看到在一个机器上的处理器数量显着的增加着。

由于调度的基本单位是线程，因此单线程的程序最多只能在一个处理器上运行。在双处理器系统上，单线程程序只使用了一半的CPU资源,在100个处理器的系统上，它只使用了1％的CPU资源。另一方面，多线程程序则可以在多个处理器上同时执行。如果设计得当，多线程程序可以更有效地利用处理器资源来提高吞吐量。

即使在单处理器系统上,多线程也能实现更好的吞吐量。如果程序是单线程的，在处理器等待同步I/O操作时将处于空闲状态。在多线程程序中，当第一个线程在等待I/O时，另一个线程仍然可以运行，允许应用程序在I/O阻塞的时候仍然能做点有用的事。（这就像在等待水沸腾时看报纸，而不是等水开了再看报纸。）

*** 1.2.2. 简化了系统建模

处理多种类型的任务(修复bug，面试新系统管理员，完成团队的绩效评估，写一个PPT）,通常比执行单一类型的任务（修复12个bug）更难以安排得当。当处理一种类型的任务时，你可以从第一件开始一直到处理完最后一个（或者你先玩完了）,你不需要花费任何精力来想清楚接下来做的是什么。另一方面，如果任务分别有多个优先级而且截至期限也不同,那么在任务之间切换的时候通常会带来一些额外的开销。

软件也是如此,顺序处理一种类型任务的程序比同时处理多种类型任务的程序更容易编写，更不容易出错，更容易测试。用不同线程分别模拟不同类型的任务或元素,使得程序更像是在顺序执行，并且将领域逻辑与其他复杂的细节隔离开来,比如任务调度，交错执行的操作，等待异步I/O和资源等等。一个复杂的异步工作流可以被分解为多个简单的同步工作流，每个工作流在单独的线程中运行，在特定的同步点上进行交互。

例如Servlet或RMI（远程方法调用）之类的框架常常会利用这个优点。框架来管理外部请求的处理细节，线程的创建和负载均衡，在适当的时候将部分的处理工作分发给适当的程序组件。实现Servlet时,就不必担心还有其他请求需要被同时处理,或者套接字的输入输出流是否阻塞.当servlet的service方法被调用来响应请求时，就可以像单线程程序一样,顺序的完成对请求的处理。这可以简化组件开发并降低此类框架的学习难度。

*** 1.2.3. 简化异步事件处理

对于从多个客户端接受socket连接的服务器程序来说,每个连接对应一个线程,线程内可以调用同步I/O操作,可以大大的简化开发工作.

当应用程序从socket中读取数据时,如果没有数据可以读取，则读操作会阻塞直到新数据到来。在单线程应用程序中，这意味着不仅处理当前请求的操作被阻塞了，而且所有其他请求的处理也停止了。为了避免这个问题，单线程服务器应用程序被迫使用非阻塞I/O调用，这要比同步I/O复杂多了而且极易出错。但是，如果每个请求都有自己的线程，则一个阻塞操作不会影响其他请求的处理。

早期的操作系统限制了一个进程能创建的线程的数量，通常只有几百个（甚至更少）。因此，操作系统提供了高效的多路复用I/O设施，例如Unix的select和poll系统调用来访问这些设施，在Java中需使用一些包(java.nio)来访问非阻塞I/O。不过现在操作系统已经大大改善了对创建大量线程的支持，在一些平台上,即使有巨量的客户端链接,每个请求一个线程的方案也变得实际可行了。[1]

*** 1.2.4. 用户界面的更快响应

早期的GUI应用程序是单线程的，这意味着或者让查询输入事件的代码（混乱的和侵入性的）遍布整个程序,或者用一个“主事件循环”来间接地执行应用程序的所有代码。如果从主事件循环调用的逻辑执行时间过长，则用户界面似乎被“冻结”了直到该逻辑执行结束，因为在该逻辑返回到主事件循环之前，后续的用户界面事件无法被处理。

现代的GUI框架,例如AWT和Swing工具包,用事件调度线程（EDT）替换了主事件循环。当发生诸如按钮按下的用户界面事件时，应用程序定义的事件处理程序将在事件线程中被调用。大多数的GUI框架都使用了一个线程来运行事件循环,即主事件循环仍然存在，但它在GUI框架中而不是应用程序的控制下运行在自己的线程中。

如果事件线程执行的任务都是短暂的，那么就能迅速的响应用户操作，因为事件线程始终能够合理快速地处理用户操作。但是，如果在事件线程中处理需要长时间运行的任务（例如拼写检查大型文档或通过网络获取资源）会损害响应性。如果用户此时执行某个操作，要过很久事件线程才能开始处理和应答。更糟糕的是，不仅UI失去了反应，而且即使UI上有取消按钮也不可能取消这个耗时的任务，因为只有在这个任务结束后,事件线程才能去处理取消按键的逻辑！但是，如果耗时的任务在另一个单独的线程中执行，那么事件线程就可以处理其他的UI事件，从提高UI的响应性。

** 1.3. 使用线程的风险

Java内置了对线程的支持是一把双刃剑。Java为此定义了语言层级的支持,还有库以及正式的跨平台的内存模型,虽然这些简化了并发应用的开发（内存模型保证了Java并发程序的一次编写，随处运行的特性），但因为有更多的程序会用到线程,变相提高了开发人员的门槛。当线程尚未普及时，并发还被看成一个“高级”主题,但现在，主流开发者必须要意识到线程安全问题。

*** 1.3.1. 安全隐患

线程安全性可能复杂得出乎意料，如果该同步的地方没有同步的话，在多个线程中的操作,其执行顺序是无法预测甚至出乎意料的。清单1.1中实现的UnsafeSequence,意图是返回单调递增的整数序列,是个简单的例子,说明了在多线程中的交错执行时是如何导致意外的结果。它在单线程环境中运行正常，确无法在多线程环境中运行正常。

[[./bad.jpg]]

清单 1.1. 线程不安全的序列生成器

#+BEGIN_SRC java
@NotThreadSafe
public class UnsafeSequence {
       private int value;

       /** Returns a unique value. */
       public int getNext() {
              return value++;
       }
}
#+END_SRC

UnsafeSequence的问题在于，在某些执行时序的情况下，两个线程调用getNext会得到相同的返回值。图1.1演示了这种情况是如何发生的。递增操作someVariable++看起来像是个单步操作，但实际上包含了三个独立的操作：读取变量值，计算+1的结果，将结果写入变量。由于在运行时,多个线程中的操作可能以任意的时间顺序交错执行，那么就可能发生下面的情况:两个线程同时读出了相同的变量值，然后两边都进行+1操作。结果是两个线程得到了相同的序号返回值。

Figure 1.1. Unlucky Execution of UnsafeSequence.getNext.

[[./figure-1-1.jpg]]

 图1.1描绘了不同线程中操作可能发生的交错时机。在图中，时间顺序是从左到右，每一行代表一个线程的活动。这些交错图通常描述了最坏的情况[2],目的是说明错误地假设事物将以特定顺序发生的危险结果。

我们给UnsafeSequence添加了一个非标准的annotation：@NotThreadSafe。这是本书中用于记录类和类成员的并发属性的几个自定义annotation之一。（类似的,其他标注在类上的annotation还有@ThreadSafe和@Immutable,详细信息请参阅附录A）.这些annotation给读者提示了线程的安全性。如果一个类标有@ThreadSafe，则用户可以放心地在多线程环境中使用其代码，代码的维护人员则会注意到必须保持相应的线程安全性，而软件分析工具可以据此识别潜在的编码错误。

UnsafeSequence是一种常见的并发错误，通常称为竞争条件。我们设计getNext期望它在多线程中总是返回唯一的序列值，但结果实际上取决于运行时操作是如何发生的,这并不是我们所期望的。

由于线程共享了相同的内存地址空间并且同时运行，因此它们可以同时访问或修改同一个变量。和其他的进程间通信机制相比,如此共享数据实在是太方便了。但它也带来了重大风险,线程可能因数据被意外更改而出现错误。允许多个线程同时访问修改同一个变量,相当于在顺序编程模型种加入了一个非顺序性的元素，既让人困惑又让人难以推断出程序的执行结果。为了让多线程程序的行为是可以预测的，必须正确协调对共享变量的访问，以便线程之间不会相互干扰。幸运的是，Java提供了同步机制来协调这类访问。

可以让getNext成为同步方法来修复UnsafeSequence的bug，如清单1.2中[3]所示，从而防止出现图1.1中的错误情况。（第2章和第3章说明了其中的原理。）

清单 1.2. 线程安全的序列号生成器

#+BEGIN_SRC java
@ThreadSafe
public class Sequence {
       @GuardedBy("this") private int Value;

       public synchronized int getNext() {
              return Value++;
       }
}

#+END_SRC 

如果没有使用synchromization关键字，那么编译器还有硬件和运行时,就有自由重新安排操作的时间和顺序，例如在寄存器或处理器的本地cache中缓存变量的值，而这些可能是暂时（也可能是永久地）对其他线程不可见的。这些技术的目的是提高性能,并且通常也是符合大家期望的，但是它们也给开发人员带来了负担，必须明确在什么位置数据是被多线程共享的，以便确认这些优化不会破坏程序的正确性。（对于操作的执行顺序JVM做了什么样的保证,以及synchronization关键字保证了什么,在第16章中清楚明白的给出了所有细节,但只要遵守第2章和第3章中的规则，你就可以安全地避免这些低层的细节。）

*** 1.3.2. 活性问题

在编写并发代码时,要特别注意线程的安全问题：不可以破坏安全性。安全性的重要性并非多线程程序所特有的,单线程程序同样也必须注意保护安全性和正确性,但多线程的使用增加了额外的安全隐患。类似地，线程的使用引入了在单线程程序中不会发生的其他形式的活性问题。

虽然安全性意味着“没有坏事发生”，但活性关注的是互补的问题,即“最终一定有好事发生”。失活错误,表示进入了一种无法取得任何进展的状态。在顺序程序中可能发生的一种形式的失活错误,是无意中造成了死循环，导致循环之后的代码永远不会被执行。线程的使用会增加额外的失活风险。例如，如果线程A正在等待线程B独占的资源，而B从不释放它，则A将永远等待。第10章描述了各种形式的失活现象以及如何避免它们，包括死锁（第10.1节），饿死（第10.3.1节）和活锁（第10.3.3节）。与大多数并发bug一样，导致失活的原因可能是难以捉摸的，因为它依赖于不同线程中事件发生的相对时间，因此并不总是能在开发或测试中表现出来。

*** 1.3.3. 性能风险

与活性有关还有性能。虽然活性意味着好事"迟早"一定会发生，但"迟早"可能还不够好,我们常常希望好事快点发生。性能问题包括的范围广泛，比如服务时间太长，响应太慢，吞吐量太低，资源消耗太大,或者伸缩性不够好。正如安全性和活性问题一样，多线程程序不仅同样有单线程程序的所有性能问题，还有其他多线程引发的影响。

在设计良好的并发应用程序中，使用线程可以提高性能，但使用线程总是带来某种程度的运行开销。上下文切换,即当调度器暂时挂起活动线程以便运行另一个线程,在运行了很多线程的应用程序中会发生的更频繁，而且带来了很高的成本：保存和恢复执行上下文，局部性的丢失以及CPU耗费在调度线程而不是运行实际功能。当线程共享数据时，必然要使用同步机制,而这将禁止一些编译器优化，将cache写入内存或者让cache无效，以及增加了共享内存总线上同步操作的数量。所有这些因素都会带来额外的性能开销,第11章会介绍如何分析和降低这些成本的技术。

** 1.4. 线程无处不在

即使您的程序从未主动创建任何一个线程，很可能你用的框架会替您创建一些线程，而在这些线程中调用的代码则必须是线程安全的。这可能给开发人员带来很大的设计和实现负担，因为开发线程安全的类比开发非线程安全的类需要更加小心和更多的分析。

所有的Java程序都会用到线程.当JVM启动时，会创建一些线程专门处理JVM的内部事务（垃圾收集，调用类的finalization方法）,还有一个运行main方法的主线程。 AWT（抽象窗口工具包）和Swing用户界面框架会创建线程以管理用户界面事件。 Timer会创建线程以执行推后执行的任务。组件框架,例如servlet和RMI,会创建线程池,并在这些线程中调用组件方法。

如果您在使用这些工具,正如大部分开发人员那样,您必须要熟悉并发和线程安全，因为这些框架会创建多个线程来调用你实现的组件。认为并发是一种“可选”或“高级”的语言特性，这样想当然没什么错,但实际情况是几乎所有Java应用程序都是多线程的，并且这些框架并不保证让你无需考虑并发问题。

当框架把并发引入了应用程序时，通常不可能将并发只局限在框架的代码中，因为框架本质上会对调用应用程序的组件，而应用程序的组件又会访问各种状态变量。 类似地，线程安全并不是到被调用的应用组件就结束了,它会散布到这些组件中会访问程序状态的所有代码路径。因此，线程安全是传染性的。

 框架通过在框架的线程中调用应用程序组件将并发引入了应用程序。组件总是需要访问应用程序的状态，因此要求访问该状态的所有代码路径都是线程安全的。

下面描述的设施都会在不是由应用程序管理的线程中调用应用的代码。虽然从这些设施开始就需要开始考虑安全性问题，但安全性问题很少在这里结束,相反，它会蔓延到应用程序中。

*定时器* 。定时器是一种方便的机制，把一个任务调度到以后再运行,一次或周期性运行。使用定时器的会使让其他的顺序执行的代码也变得复杂了，因为TimerTasks是在由Timer管理的线程中执行的，而不是应用程序管理的线程中。 如果TimerTask和应用程序的其他线程都会访问同一个数据，那么不仅仅TimerTask需要是线程安全的，而且访问该数据的任何其他Java类也必须是线程安全的。 通常，实现此目的的最简单方法是确保TimerTask访问的对象本身是线程安全的，从而将线程安全性封装在共享对象中。
 
 *Servlets和JavaServer Pages（JSP）* servlets框架被设计为提供一个基础设施,涵盖如何部署一个Web应用,还有对远程HTTP客户端发来的请求进行分发。到达服务器的请求可能在经过一系列的filter(过滤器)处理后,被分派到适当的servlet或JSP去处理。每个servlet代表一个处理应用逻辑的组件，在访问量巨大的Web站点中，多个客户端可能同时访问同一个servlet提供的服务。servlet规范要求servlet应该准备好,能够被多个线程同时调用。换句话说，servlet应该是线程安全的。

即使您可以保证任何时候仅在一个线程中调用某个servlet，在构建Web应用程序时仍然需要注意线程安全性。 一个Servlet通常会访问与其他servlet共享的状态信息，例如应用程序上下文中的对象（存储在ServletContext中的对象）或会话上下文中的对象（存储在对应每个客户端的HttpSession中的对象）。当一个servlet访问那些被多个servlet或请求所共享的对象时，它必须正确地处理对这些对象的访问，因为可能有多个请求在从不同的线程中同时访问这些对象。 Servlet和JSP，以及存储在作用域容器（如ServletContext和HttpSession）中的servlet filter(过滤器)和对象，都需要是线程安全的。

 *远程方法调用* RMI允许您调用在另一个JVM中运行的对象的方法。当您使用RMI调用远程方法时，方法的参数将被打包（编组）到字节流中，并通过网络传送到远程的JVM，并在远程JVM中解包（解组）并传递给远程方法。

当RMI代码调用您的远程对象时，调用到底是发生在哪个线程中？你无法知道，但它绝对不是在你创建的线程中,你的对象是在一个由RMI管理的线程中被调用。RMI会创建多少个线程？同一个远程对象的同一个方法,会不会在多个RMI线程中被同时调用？[4]

远程对象必须正确处理多线程的安全问题：正确协调其他对象来访问共享状态，以及对远程对象自身状态的访问（因为同一对象可以同时在多个线程中被同时调用）。与servlet一样，RMI对象应该准备好被多个线程同时调用，并且保证自己是线程安全的。

 *Swing和AWT* GUI应用程序本质上是异步的。用户可以随时选择一个菜单项或按下一个按钮，并且希望应用程序能够立即响应,即使有其他操作正执行了一半。 Swing和AWT通过创建一个单独的线程来解决这个问题,这个线程专门处理用户发起的事件,以及更新用户视图。

Swing组件（如JTable）不是线程安全的。相反，Swing程序通过将对GUI组件的所有访问限制在事件线程中来实现线程安全。如果应用程序想要在事件线程之外的线程中操作GUI，则必须想办法让操作GUI的代码能够在事件线程中运行。

当用户执行UI动作时，一个事件处理程序在事件线程中被调用,以执行用户请求的任何操作。如果事件处理程序需要访问的应用状态（例如正在编辑的文档）,也可能在其他线程中被访问，那么事件处理程序以及访问该状态的任何其他代码都必须是线程安全的。
