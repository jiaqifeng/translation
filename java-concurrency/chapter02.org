* Part I: 基础部分

* Chapter 2 线程安全

也许令人惊讶的是，并发编程并不全是是关于线程或锁的，就像民用土木工程不仅仅只有铆钉和工字梁一样。当然，建造一座不会塌掉的大桥需要正确使用大量的铆钉和工字梁，就像构建并发程序需要正确使用线程和锁一样。但这些只是一些机制而已。编写线程安全的代码的核心是管理对状态的访问，特别是对共享的,可变的状态的访问。

不太正式地说，对象的状态就是它的数据，存储在状态变量（例如类的成员变量或类的静态字段）中。一个对象的状态可以包括来自其他依赖对象的字段,HashMap的状态有一个部分存储在HashMap对象本身中，还有一部分存储在许多Map.Entry对象中。任何可以影响一个对象的外部可见的行为的数据,都可以看作是对象状态的一部分。

我们说共享，意思是一个变量可以被多个线程访问,我们说可变，意思是变量的值在其生命周期中可能会改变。我们说线程安全，好像是在说代码，但其实真正想说的是避免数据被不受控制的并发所访问。

对象是否应该是线程安全的,取决于它会不会从多个线程中被访问。这是对象的一个属性,即在程序中如何被使用，而不是它的执行了什么操作。让一个对象成为线程安全的，需要使用同步操作来协调所有对其可变状态的访问,如果不这样做,可能会导致数据被破率以及其他不良后果。

当多个线程都会访问同一个状态变量时，并且其中一个线程可能会对变量赋值，那么所有线程都必须使用同步操作来协调对这个变量的访问。 Java中主要的同步机制是synchronized关键字，它提供独占的锁定，但术语“同步操作”还包括使用volatile变量，显式锁和原子变量。

你应该放弃存在某些特殊情况,不需要遵守上面这些规则的想法。 去掉几个同步操作的程序看起工作正常，能通过测试并且很多年来运行良好，但它仍然可能随时崩溃或失败。

  如果多个线程在没有正确同步的情况下访问同一个可变的状态变量，则程序将出现错误。 有三种方法可以解决它：

  - 不要跨线程共享状态变量;
  - 使状态变量不可变,或者
  - 所有对状态变量的访问,都是同步的。

如果你在设计的时候没有考虑并发问题，那么类的一些方法可能需要对设计进行重大修改，因此想修复问题可能没有上面的建议看起来那么简单。 /一开始就把类设计为线程安全的,要比后来为了线程安全而改进它要容易得多/.

在大型程序中，要识别一个变量是不是会被多个线程访问能是很复杂的。幸运的是，面向对象技术中,那些帮助你写出组织良好，易于维护的类（如封装和数据隐藏）的方法，也可以帮助您创建线程安全的类。访问一个特定变量的代码越少，就越容易确保这些代码都正确的被同步了，并且更容易推断在什么条件下,该定变量会被访问。 Java语言不会强制您封装状态,在公共字段（甚至公共静态字段）中存储状态或将内部对象的引用提供出去也是完全被允许的,但是程序状态被封装的越好，您的程序就越容易实现线程安全，并帮助维护者保持线程安全。

 在设计线程安全的类时，好的面向对象技术,如封装，不可变和保持定义明确的守恒性质,都将是您最好的朋友。

良好的面向对象设计技术与现实世界的要求并不总是一致的,可能为了更好的性能,或者保持对遗留代码的向后兼容性,不得不在其与良好设计规则之间进行折衷。有时抽象和封装会降低性能,虽然不像许多开发人员所认为的那样频繁,但是好的实践是首先保证代码功能正确，然后想办法让它变得更快。即便如此，只有对性能进行了实际测量而且确实需要更好的性能的时候，同时优化被实际测量验证有效的情况下,追求优化才是有意义的。[1]

如果你决定了必须解除封装，也并非不可以。你仍然可以实现线程安全，这只是难了许多。此外，程序的线程安全性将更加脆弱，不仅开发成本和风险增加了，维护成本和风险也增加了。第4章描述了在哪些条件下,放松对状态变量的封装是安全的。

到目前为止，我们几乎可以互换地使用“线程安全的类”和“线程安全的程序”这两个术语。但是一个完全由线程安全的类构建的程序一定是线程安全的吗？这可不一定,完全由线程安全的类组成的程序可能不是线程安全的，并且线程安全的程序也可能包含了线程安全不安全的类。在第4章中讨论了有关如何组合使用线程安全的类的问题。在任何情况下，只有当类封装自己的状态时，线程安全的类这个概念才有意义。线程安全这个术语也可以是指某块代码，但它是实际是关于状态的，并且指的是封装了这个状态的所有代码时才有意义，可能是单个对象也可能是整个程序。

** 2.1. 什么是线程安全

出乎意料的是,我们很难给线程安全一个明确的定义。定义越是正式,定义就越是复杂,以至对实践的指导越少,越难以被直观的理解，下面的讲的都是不太正式的描述，有点像是循环定义的味道。快速的用谷歌搜索一下,可以找到如下的众多“定义”：

 ...可以在多个程序线程中被调用，而不会在线程之间进行错误的交错。
 ...可以同时在多个线程中被调用，而不需要调用者执行任何额外操作。

看到这样的定义，难怪我们发现到底什么是线程安全令人困惑！这听起来就好像是在说"如果一个类是线程安全的,当它能在多线程中被安全使用”。对于这样的陈述,你甚至没什么好争论的，而且它也带不来什么实际帮助。我们如何区分哪个类是线程安全的,哪个不是？进一步说, “安全”的涵义是什么？

线程安全的定义中,最核心的应该是正确性。如果我们对线程安全的定义是模糊的，那是因为我们没有清晰的定义什么是正确性。

正确性意味着一个类符合其功能规范。好的规范定义了,约束了对象可能的状态的守恒性质,和描述其操作效果的后置条件。由于我们经常没有为我们的类编写有效的规范，我们怎么可能知道代码是正确的？我们没法知道，但是这并没有阻止我们说代码是"正确"的,当我们相信“代码能工作的”的时候。对我们大多数人来说,这种“对代码的信心”和"正确性"没什么差别，所以就让我们认为单线程代码的正确性就像是“我看到所以我知道”吧。如此乐观地定义后,就可以识别什么是“正确”的了，现在我们现在可以用不那么循环定义的方式来定义线程安全性：当在多个线程中被访问时，一个类能够持续的正常运行,那么称这个类是线程安全的。

 一个类是线程安全的,当它在多个线程中被访问时,行为总是正确的，无论运行时如何调度,或这些线程的执行是如何交错的，并且调用者的代码中无需进行额外的同步或其他的协调。

任何单线程程序也可以看成是一个合法的多线程程序，如果它在单线程环境中都不正确，它也不可能是线程安全的。[2]如果一个对象被正确的实现，则不存在一个顺序的操作(调用公共方法和读写公共字段)序列,能破坏其任何守恒性或后置条件。对于一个线程安全的类的来说,任何一组不论顺序的还是并发的操作,都不能让该实例变成不合法的状态。

 线程安全类封装了所有必要的同步操作，使得客户端无需再进行任何同步操作。

*** 2.1.1. 例子: 无状态的Servlet

在第1章中，我们列出了许多框架，这些框架创建线程并从这些线程调用用户编写的组件，把组件的线程安全性问题留给了你。 通常，需要考虑线程安全性的问题,不是因为你想要使用线程，而是因为你使用了像Servlets框架这样的设施。 我们将从一个简单的示例开始,基于servlet的实现的因数分解服务,通过不断的添加新功能来扩展它，并一直保持其线程安全性。

清单2.1显示了我们的简单的提供因数分解的servlet服务。 它将从servlet请求中解析出的待分解的数字，并将分解结果打包到servlet的响应里去。

清单 2.1. 一个无状态的servlet

#+BEGIN_SRC java
@ThreadSafe
public class StatelessFactorizer implements Servlet {
       public void service(ServletRequest req, ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              BigInteger[] factors = factor(i);
              encodeIntoResponse(resp, factors);
       }
}
#+END_SRC 

与大多数servlet一样，StatelessFactorizer是无状态的：没有任何成员变量，如数值或对其他类类的引用。 计算中的所有临时状态仅保存在局部变量中,而局部变量是仅存在于当前线程的堆栈中，并且只能由当前线程访问。 一个线程访问StatelessFactorizer时,它无法影响另一个线程访问同一个StatelessFactorizer的结果; 因为两个线程不共享状态，就好像它们访问的是两个不同的实例一样。 由于访问无状态对象的一个线程的操作不会影响另一个线程中的操作的正确性，因此无状态对象是线程安全的。

 无状态对象始终是线程安全的。

大多数servlet的实现都是无状态的，这一事实大大减轻了开发servlet成为线程安全的负担。 只有当servlet想要在多个请求之间保存某些信息的时候，才需要考虑线程安全的问题。

** 2.2. 原子性

如果我们给无状态对象增加一个状态会发生什么？ 假设我们想要添加一个“命中计数器”来记录已经处理的请求个数。 显而易见的方法是向servlet添加一个长整数字段并在每个请求中将其递增，如清单2.2中的UnsafeCountingFactorizer所示。

清单2.2。 在不使用同步的情况下对请求计数的Servlet。 不要学这个。

[[bad.jpg]]
#+BEGIN_SRC java

@NotThreadSafe
public class UnsafeCountingFactorizer implements Servlet {
       private long count = 0;
       public long getCount() { return count; }
       public void service(ServletRequest req, ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              BigInteger[] factors = factor(i);
              ++count;
              encodeIntoResponse(resp, factors);
       }
}
#+END_SRC 

不幸的是，UnsafeCountingFactorizer不是线程安全的，虽然它在单线程环境中可以正常工作。就像第6页上的UnsafeSequence一样，它记录的总数很可能比实际个数要少。虽然++count的语法很紧凑,看起来像个单一操作，但这个操作不是原子的，即不是不可分割的操作。相反，它对应了三个顺序的操作：获取当前值，加一，然后将新值写回。这是读-修改-写操作的例子，其结果和之前的状态是相关的。

第6页的图1.1显示了如果两个线程在没有同步的情况下尝试同时对计数器进行递增操作时会发生什么。如果你不太走运的话,当计数器最初是9，两个线程都可以读取到这个值是9，加一，然后每个线程中都将计数器设置为10.这显然不是我们想看到的,一次递增操作的结果被丢掉了,计数器永久的少记录了一个请求。

您可能认为在Web的服务中点击次数少了几个,这种不精确是可接受的，而且有时确实如此。但是，如果计数器是用于生成序列号或唯一对象标识符，则两次都返回相同的值,可能会严重的破坏了数据完整性。[3]不幸的时序中可能得到错误结果,在并发编程中非常重要，因此它有个特定的名字：竞争条件。

*** 2.2.1. 竞争条件

在UnsafeCountingFactorizer中出现了好几种竞争条件，使其结果不可靠。当计算的正确性取决于运行时的多个线程的彼此交错执行的时机时，就会发生竞争条件.换句话说，正确答案依赖于幸运的时机。[4]最常见的竞争条件的类型是check-then-act(检查后修改)，根据一个可能已经过时的事实来决定下一步该做什么。

我们经常在现实生活中遇到竞争条件。假设你计划中午在大学路的星巴克与朋友见面。但是当你到达那里时，你会发现大学路上有两个星巴克，而你不确定哪一个星巴克是会面的地点。在12:10，你在星巴克A没看到你的朋友，所以你走到星巴克B看他是否在那里，但他也不在那里。有几种可能性：你的朋友迟到了，两个星巴克里都没有你的朋友;你的朋友在你离开星巴克A后走进了A;或者你的朋友在星巴克B，没看到你所以正在前往星巴克A去找你.让我们假设最坏的情况,也是最后一种可能性。现在是12点15分，你们两人都去过两个星巴克了，你们都在怀疑是不是对方失约了。现在你该怎么办？再去另一个星巴克看看？回多少次才算个头？除非你们已经约定了一个协议，否则你可能一天都在大学大道上走过来走过去，沮丧至极。

“我只是去另一家星巴克看看他是不是在那”,这个方法的问题是，当你走在街上时，你的朋友可能也走出去找你了。你到了星巴克A，看到“他不在这里”，然后再去B找他。到了星巴克B还是没看到你的朋友,你又再去A找.但是你不能同时既去A找又去B找。从街道这头走到那头总是需要几分钟，而在这几分钟内，系统的状态可能已经改变了。

星巴克的例子说明了什么是竞争条件，你的预期结果（与你的朋友见面）取决于事件发生的相对时间（当你或你的朋友,到达一个星巴克或另一个的时刻，还有你会等多久再去另一家看看,等等）。当你从星巴克A的前门离开时，你的朋友不在A的情况可能就改变了;他可能刚好从后门走进A，而你却不知道。观察结果已经无效了,这证实竞争条件的特性,根据可能已经失效的观察结果来做出决定或进行计算。这种类型的竞争条件称为check-then-act(检查后行动)：你观察到某些事情（文件X不存在）然后根据观察结果采取行动（创建文件X）;但实际上可能在查看它的时刻和采取动作的时刻之间,原来观察的结果已经改变了（其他人在此期间创建了X），这必然导致问题（未预期的异常，数据被覆盖，文件损坏）。

*** 2.2.2. 例子: 懒初始化中的竞争条件

应用check-then-act的一个常见情况是懒初始化。 延迟初始化的目的是将一个对象的初始化操作尽可能的推迟，直到一次需要用到这个对象的时候再初始化，同时确保它只被初始化一次。 清单2.3中的LazyInitRace说明了懒初始化的习惯用法。 getInstance方法首先检查ExpensiveObject是否已经被初始化，是的话返回当前实例,否则创建一个新实例并保存其引用,之后就可以直接返回这个引用，从而避免了之后再次进行初始化这种昂贵的操作。

清单 2.3. 懒初始化中的竞争条件.请勿模仿.

[[bad.jpg]]
#+BEGIN_SRC java

@NotThreadSafe
public class LazyInitRace {
       private ExpensiveObject instance = null;

       public ExpensiveObject getInstance() {
              if (instance == null)
                  instance = new ExpensiveObject();
              return instance;
       }
}
#+END_SRC 

LazyInitRace中的竞争条件可能导致正确性被破坏。假设线程A和B同时调用了getInstance。 A看到instance为null，然后创建了一个新的ExpensiveObject。 B也会检查instance是否为null。此时instance是否为null取决于无法可预测的执行时机，包括调度时机和A创建一个新的ExpensiveObject和设置instance所消耗的时间。当B也发现instance为null，则getInstance返回给两个调用者可能是两个不同的结果，虽然我们期望getInstance总是应该返同一个实例。

UnsafeCountingFactorizer中的命中计数器是另一种竞争条件。"读改写"的操作（如递增计数器）,定义了一种转换,根据之前的状态转换为一个新的状态。要增加计数器，您必须知道当前的值，并确保在更新成功之前没有其他人更改或使用这个值。

与大多数并发错误一样，竞争条件并不总是导致错误：还需要时机不那么幸运。但是竞争条件会导致严重的问题。如果LazyInitRace实例化的是整个应用程序范围内的注册机制，那么返回不同的实例可能导致一些注册的数据被丢失,或者程序的不同部分分别看到了两套注册数据。如果UnsafeSequence是在一个持久性框架中用于生成实体ID，则两个不同的对象可能最终具有相同的ID，从而破坏了身份完整性的要求。

*** 2.2.3. 复合操作

LazyInitRace和UnsafeCountingFactorizer都包含了一个操作序列，对于操作同一状态的其他操作序列,这个操作序列应是原子的,或者说是不可分的。为了避免出现竞争条件，必须有一种方法可以防止其他线程在我们修改一个变量的时候也用到这个变量，这样我们就可以确保其他线程只能在我们开始之前或完成之后,再读取或修改状态，而不是在我们的操作中间。

 说两组操作A和B是彼此互为原子的,如果从执行A的线程的角度看，当另一个线程执行B时，或者B中的所有操作,要么都执行完了或者一个也没执行。说一个原子操作,意思是它和包含它在内的所有使用同一个状态的所有操作,都是彼此互为原子的。

如果UnsafeSequence中的增量操作是原子的，则第6页的图1.1中所示的竞争条件不会发生，并且每次执行增量操作都会得到期望的将计数器加一的效果。为了确保线程安全，check-then-act操作序列（如懒初始化）和read-modify-write(读改写)操作序列（如增加计数）必须始终是原子的。我们统一将check-then-act和read-modify-write的操作序列称为复合操作：为了保证线程安全,必须以原子方式执行的操作序列。在下一节中，我们将考虑Java的内置用于保证原子性的锁机制。现在，我们用另一种方式,使用Java提供的线程安全的类,来解决问题，如清单2.4中的CountingFactorizer所示。

清单 2.4. 用AtomicLong实现技术的Servlet.

#+BEGIN_SRC java

@ThreadSafe
public class CountingFactorizer implements Servlet {
       private final AtomicLong count = new AtomicLong(0);

       public long getCount() { return count.get(); }

       public void service(ServletRequest req, ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              BigInteger[] factors = factor(i);
              count.incrementAndGet();
              encodeIntoResponse(resp, factors);
       }
}
#+END_SRC 

java.util.concurrent.atomic包提供了,对数值或对象引用的变量进行原子操作的类。通过把long类型替换为AtomicLong，我们就能保证所有对计数器的操作都是原子的。[5]因为servlet的状态就只包括计数器的状态,由于计数器是线程安全的，所以我们的servlet又变成是线程安全的了。

为了实现因数分解servlet的请求计数功能,我们使用现有的线程安全类AtomicLong来进行计数，从而保证了线程安全性。当给一个无状态类添加唯一一个状态时，只要这个状态全部由一个线程安全的对象来管理，那么新的类将还是线程安全的。但是，正如我们将在下一节中看到的那样，从只有一个状态变量到有多个状态变量,就不像从无到有那么简单了。

 在条件允许的情况下，使用现有的线程安全的对象（如AtomicLong）来管理类的状态。使用现有的线程安全对象,而不是随意的用一个变量,来管理状态，将更容易维护和验证程序的线程安全性。

** 2.3. 锁

当servlet的整个状态只有一个的时候,使用线程安全对象来管理这个状态就能保证线程安全。 但是如果我们想在servlet中添加更多状态，那么使用更多的线程安全的状态变量就可以了吗？

设想来自两个客户端请求连续对同一个数字进行因数分解,我们希望缓存最近的计算的结果来提高servlet的性能。（这不太可能是一种有效的缓存策略;我们在5.6节中提供了更好的缓存策略。）为了实现这一优化，我们需要记录两个状态：最后一个被请求的数值和分解的结果。

我们使用AtomicLong以线程安全的方式管理计数器状态; 我可能用它的堂兄，AtomicReference，[6]来管理最后一个被请求的数值及其分解结果吗？ 我们试着在清单2.5中的UnsafeCachingFactorizer这样处理。

清单 2.5. Servlet的缓存没能保证原子性的例子.请勿模仿.
[[bad.jpg]]
#+BEGIN_SRC java

@NotThreadSafe
public class UnsafeCachingFactorizer implements Servlet {
       private final AtomicReference<BigInteger> lastNumber
              = new AtomicReference<BigInteger>();
       private final AtomicReference<BigInteger[]> lastFactors
              = new AtomicReference<BigInteger[]>();

       public void service(ServletRequest req, ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              if (i.equals(lastNumber.get()))
                  encodeIntoResponse(resp, lastFactors.get() );
              else {
                     BigInteger[] factors = factor(i);
                     lastNumber.set(i);
                     lastFactors.set(factors);
                     encodeIntoResponse(resp, factors);
              }
       }
}
#+END_SRC 

不幸的是，这种方法达不到目的。即使每个原子引用分别都是线程安全的，但UnsafeCachingFactorizer还是含有竞争条件可能导致错误发生。

线程安全性的定义要求保证守恒性(不变性)，而不管多个线程中的操作彼此交错执行的时机。 UnsafeCachingFactorizer的一个守恒性是lastFactors中缓存的因子的乘积等于lastNumber中缓存的值;只有当这个守恒性始终存在时，我们的servlet才是正确的。当多个变量参与在一个守恒性中时，它们就不再是独立的了：一个变量的值约束了其他变量可能的取值。因此，在更新一个变量时，必须保证其他的更新都是原子的。

当不幸的时机发生时，UnsafeCachingFactorizer会违反这个守恒性。只保证引用的原子性，即每个set操作都是原子的,我们不能保证更新lastNumber和lastFactors是同时的;当一个引用被修改而另一个没有被修改时，在这个时间点上则有一个漏洞，此时其他的线程会发现守恒性不再成立。类似地，我们也不能同时读取这两个引用：在线程A读取这两个值之间，线程B可以更改它们，又一次的,A会发现守恒性不再成立。

 要保持状态一致性，需要在单个原子操作中更新所有相关的状态变量。

*** 2.3.1. 内置锁

Java提供了一个内置的锁机制来保证原子性：synchronized块。 （在第3章中将介绍锁和其他同步机制另一方面的重要问题,可见性。）synchronized块包括两部分：一个对象的引用作为锁，以及被锁住的代码块。 synchronized方法则是一种简写方式,其被锁住的代码块是整个方法的代码，拥有该方法的对象作为锁。 （对于synchronized的静态方法,其对应的Class类型的对象作为锁。）

#+BEGIN_SRC java

synchronized (lock) {
       // Access or modify shared state guarded by lock
}
#+END_SRC 

每个Java对象都可以隐式地作为一个锁被使用;这种内置的锁机制称为内部锁或monitor锁。执行线程在进入同步块之前自动获取锁，并在离开同步块时自动释放锁，无论是正常离开还是由于异常而离开同步块。获取内部锁定的唯一方式是进入这个锁所锁定的同步块或方法。

Java中的内部锁相当于互斥锁（mutex），这意味着最多只有一个线程可以拥有锁。当线程A尝试获取线程B持有的锁时，A必须等待或阻塞，直到B释放锁。如果B永不释放，则A会永远等待下去。

由于一次只有一个线程可以执行由一个锁所保护的任一个代码块，因此由同一锁保护的所有同步块相对于彼此被原子地执行。在并发上下文中原子性的意义,和应用程序中的事务性相同,一组语句作为单个不可分割的单元被执行。没有任何一个执行同步块的线程,可以观察到另一个线程位于由同一个锁保护的同步块的中间状态。

同步机制可以轻松地恢复因数分解servlet的线程安全性。清单2.6让service方法是snychronized，因此一次只有一个线程可以执行service方法。 SynchronizedFactorizer现在是线程安全的;然而，这种方法过于极端，因为这阻止了servlet同时服务于多个客户端，从而导致响应性差得令人无法接受。这个问题,一个性能问题，而不是一个线程安全问题,将在第2.5节中讨论。

清单 2.6. 缓存了结果的Servlet,但是性能无法被接受.请勿模仿.
[[bad.jpg]]
#+BEGIN_SRC java

@ThreadSafe
public class SynchronizedFactorizer implements Servlet {
       @GuardedBy("this") private BigInteger lastNumber;
       @GuardedBy("this") private BigInteger[] lastFactors;

       public synchronized void service(ServletRequest req,
                                                           ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              if (i.equals(lastNumber))
                  encodeIntoResponse(resp, lastFactors);
              else {
                    BigInteger[] factors = factor(i);
                    lastNumber = i;
                    lastFactors = factors;
                    encodeIntoResponse(resp, factors);
              }
       }
}
#+END_SRC 
donehere
*** 2.3.2. Reentrancy

当一个线程请求另一个线程已经拥有的锁时，请求线程会阻塞。但是因为内部锁是可重入的，所以如果线程试图获取它已经拥有的锁，则请求成功。重入意味着在每个线程而不是每次调用的基础上获取锁。[7]通过将每个锁与获取计数和拥有线程相关联来实现重入。当计数为零时，锁定被视为未保留。当线程获取先前未保留的锁时，JVM会记录所有者并将获取计数设置为1。如果同一个线程再次获得锁定，则计数递增，并且当拥有线程退出同步块时，计数递减。当计数达到零时，锁定被释放。

重入有助于锁定行为的封装，从而简化了面向对象的并发代码的开发。如果没有可重入锁，清单2.7中非常自然的代码（其中子类重写synchronized方法然后调用超类方法）将会死锁。因为Widget和LoggingWidget中的doSomething方法都是同步的，所以每个方法都会在继续之前尝试获取Widget上的锁。但是如果内部锁不是可重入的，那么对super.doSomething的调用将永远无法获取锁，因为它将被认为已经被保持，并且该线程将永久停止等待它永远无法获取的锁。在这种情况下，重入可以使我们免于死锁。

Listing 2.7. Code that would Deadlock if Intrinsic Locks were Not Reentrant.
#+BEGIN_SRC java

public class Widget {
       public synchronized void doSomething() {
              ...
       }
}

public class LoggingWidget extends Widget {
       public synchronized void doSomething() {
              System.out.println(toString() + ": calling doSomething");
              super.doSomething();
       }
}
#+END_SRC 

** 2.4. Guarding State with Locks

因为锁可以对它们保护的代码路径进行序列化[8]访问，所以我们可以使用它们来构建协议以保证对共享状态的独占访问。遵循这些协议始终可以确保状态一致性。

对共享状态的复合操作（例如递增命中计数器（读取 - 修改 - 写入）或延迟初始化（check-then-act））必须是原子的，以避免竞争条件。在复合动作的整个持续时间内持有一个锁可以使该复合动作成为原子。但是，仅使用synchronized块包装复合动作是不够的;如果使用同步来协调对变量的访问，则在访问变量的任何地方都需要它。此外，当使用锁来协调对变量的访问时，必须在访问该变量的任何地方使用相同的锁。

假设只有在写入共享变量时才需要使用同步，这是一个常见的错误。这是不正确的。 （其原因将在3.1节中更清楚。）

 对于可以由多个线程访问的每个可变状态变量，必须在保持相同锁的情况下执行对该变量的所有访问。在这种情况下，我们说该变量由该锁保护。

在清单2.6中的SynchronizedFactorizer中，lastNumber和lastFactors由servlet对象的内部锁保护;这由@GuardedBy注释记录。

对象的内在锁与其状态之间没有固有的关系;对象的字段不需要通过其内部锁来保护，尽管这是许多类使用的完全有效的锁定约定。获取与对象关联的锁不会阻止其他线程访问该对象 - 获取锁的唯一方法是阻止任何其他线程执行获取相同的锁。每个对象都有一个内置锁的事实只是一个方便，所以你不需要显式创建锁对象。[9]您可以构建锁定协议或同步策略，以便安全地访问共享状态，并在整个程序中一致地使用它们。

 每个共享的可变变量应该只用一个锁来保护。向维护者明确指出哪些是锁定的。

常见的锁定约定是将所有可变状态封装在对象中，并通过使用对象的内部锁同步访问可变状态的任何代码路径来保护它免受并发访问。许多线程安全类使用此模式，例如Vector和其他同步集合类。在这种情况下，对象的状态中的所有变量都由对象的内部锁保护。但是，这种模式并没有什么特别之处，编译器和运行时都没有强制执行这种（或任何其他）锁定模式。[10]通过添加新方法或代码路径并忘记使用同步，也很容易意外破坏此锁定协议。

并非所有数据都需要通过仅从多个线程访问的锁定可变数据来保护。在第1章中，我们描述了如何添加一个简单的异步事件（如TimerTask）可以创建贯穿整个程序的线程安全要求，尤其是在程序状态封装不良的情况下。考虑一个处理大量数据的单线程程序。单线程程序不需要同步，因为没有数据在线程之间共享。现在想象一下，您想要添加一个功能来创建其进度的定期快照，这样如果它崩溃或必须停止它就不必从头开始。您可以选择使用每十分钟关闭的TimerTask执行此操作，将程序状态保存到文件中。

由于TimerTask将从另一个线程（由Timer管理的线程）调用，现在快照中涉及的任何数据都由两个线程访问：主程序线程和Timer线程。这意味着TimerTask代码不仅必须在访问程序状态时使用同步，而且程序其余部分中的任何代码路径也必须接触相同的数据。以前不需要同步的内容现在需要在整个程序中进行同步。

当一个变量被一个锁保护时 - 意味着每次访问该变量都是在保持锁的情况下执行的 - 你确保一次只有一个线程可以访问该变量。当一个类具有涉及多个状态变量的不变量时，还有一个额外的要求：参与该不变量的每个变量必须由同一个锁保护。这允许您在单个原子操作中访问或更新它们，从而保留不变量。 SynchronizedFactorizer演示了这条规则：缓存的数字和缓存的因子都由servlet对象的内部锁保护。

 对于涉及多个变量的每个不变量，该不变量中涉及的所有变量必须由同一个锁保护。

如果同步是解决竞争条件的问题，为什么不宣布每个方法同步？事实证明，同步的这种不加选择的应用可能是同步太多或太少。仅像Vector一样同步每个方法，不足以在Vector原子上渲染复合动作：

#+BEGIN_SRC java

if (!vector.contains(element))
    vector.add(element);
#+END_SRC

即使不包含和添加都是原子的，这种在put-if-absent操作中的尝试都有竞争条件。 虽然同步方法可以使单个操作成为原子，但是当多个操作组合成复合操作时，需要额外的锁定。 （有关为线程安全对象安全地添加其他原子操作的一些技术，请参见第4.4节。）同时，同步每个方法都会导致活跃或性能问题，正如我们在SynchronizedFactorizer中看到的那样。

** 2.5. Liveness and Performance

在UnsafeCachingFactorizer中，我们在分解servlet中引入了一些缓存，以期提高性能。 缓存需要一些共享状态，这又需要同步来维护该状态的完整性。 但是我们在SynchronizedFactorizer中使用同步的方式使它表现不佳。 SynchronizedFactorizer的同步策略是使用servlet对象的内部锁来保护每个状态变量，并且该策略是通过同步整个服务方法来实现的。 这种简单，粗粒度的方法恢复了安全性，但价格昂贵。

Figure 2.1. Poor Concurrency of SynchronizedFactorizer.
[[figure-2-1.jpg]]

由于服务是同步的，因此只有一个线程可以同时执行它。这颠覆了servlet框架的预期用途 - servlet能够同时处理多个请求 - 如果负载足够高，可能会导致受挫的用户。如果servlet占用大量数据，则其他客户端必须等到当前请求完成后才能在新数字上启动servlet。如果系统有多个CPU，即使负载很高，处理器也可能保持空闲状态。在任何情况下，即使是短时间运行的请求（例如缓存值的请求）也可能需要很长时间，因为它们必须等待以前长时间运行的请求才能完成。

图2.1显示了多个请求到达同步分解servlet时会发生什么：它们排队并按顺序处理。我们将此Web应用程序描述为表现出较差的并发性：同时调用的数量不仅取决于处理资源的可用性，还取决于应用程序本身的结构。幸运的是，通过缩小同步块的范围，可以很容易地提高servlet的并发性，同时保持线程安全。你应该注意不要使同步块的范围太小;您不希望将应该是原子的操作划分为多个同步块。但是尝试从同步块中排除不影响共享状态的长时间运行操作是合理的，这样在长时间运行的操作正在进行时，不会阻止其他线程访问共享状态。

清单2.8中的CachedFactorizer重新构造servlet以使用两个独立的同步块，每个块仅限于一小段代码。一个保护check-then-act序列，测试我们是否可以返回缓存的结果，另一个守卫更新缓存的数字和缓存的因子。作为奖励，我们重新引入了点击计数器，并添加了一个“缓存命中”计数器，在初始同步块中更新它们。因为这些计数器也构成共享可变状态，所以我们必须在访问它们的任何地方使用同步。在同步块之外的代码部分仅在本地（基于堆栈的）变量上操作，这些变量不在线程之间共享，因此不需要同步。

Listing 2.8. Servlet that Caches its Last Request and Result.
#+BEGIN_SRC java

@ThreadSafe
public class CachedFactorizer implements Servlet {
       @GuardedBy("this") private BigInteger lastNumber;
       @GuardedBy("this") private BigInteger[] lastFactors;
       @GuardedBy("this") private long hits;
       @GuardedBy("this") private long cacheHits;

       public synchronized long getHits() { return hits; }
       public synchronized double getCacheHitRatio() {
              return (double) cacheHits / (double) hits;
       }

       public void service(ServletRequest req, ServletResponse resp) {
              BigInteger i = extractFromRequest(req);
              BigInteger[] factors = null;
              synchronized (this) {
                     ++hits;
                     if (i.equals(lastNumber)) {
                         ++cacheHits;
                         factors = lastFactors.clone();
                  }
              }
              if (factors == null) {
                  factors = factor(i);
                  synchronized (this) {
                         lastNumber = i;
                         lastFactors = factors.clone();
         .         }
              }
              encodeIntoResponse(resp, factors);
       }
}
#+END_SRC 

CachedFactorizer不再使用AtomicLong作为命中计数器，而是恢复使用长字段。在这里使用AtomicLong是安全的，但是比CountingFactorizer的好处少。原子变量对于在单个变量上实现原子操作很有用，但由于我们已经使用同步块来构造原子操作，因此使用两种不同的同步机制会令人困惑，并且不会提供性能或安全性好处。

CachedFactorizer的重构在简单性（同步整个方法）和并发性（同步最短的代码路径）之间提供了平衡。获取和释放锁有一些开销，因此不希望将同步块分解太远（例如将因子分解成自己的同步块），即使这不会损害原子性。 CachedFactorizer在访问状态变量时以及复合操作的持续时间内保持锁定，但在执行可能长时间运行的分解操作之前释放它。这样可以在不过度影响并发性的情况下保持线程安全;每个同步块中的代码路径“足够短”。

决定同步块的大小可能需要在竞争设计力量之间进行权衡，包括安全性（不得泄露），简单性和性能。有时简单性和性能彼此不一致，尽管CachedFactorizer说明，通常可以找到合理的平衡。

 简单性和性能之间经常存在紧张关系。在实施同步策略时，为了性能，抵制过早牺牲简单性（可能危及安全性）的诱惑。

每当你使用锁定时，你应该知道块中的代码正在做什么以及花费很长时间执行的可能性。持有锁很长一段时间，或者是因为你正在做一些计算密集型的事情，或者因为你执行了一个潜在的阻塞操作，所以会带来生机或性能问题的风险。

 在长时间计算或操作过程中避免持有锁，否则可能无法快速完成，例如网络或控制台I / O.
